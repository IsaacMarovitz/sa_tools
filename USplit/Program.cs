using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using SonicRetro.SAModel;
using SA_Tools;
using System.Linq;

namespace USplit
{
	public struct ItemDescriptor
	{
		public string ObjectType;
		public string ObjectName;
	}
	public struct ItemParams
	{
		public int IntParam;
		public string StringParam;
		public bool BoolParam;
	}
	class Program
	{
		static bool LabelIsAutoGenerated(string label)
		{
			string[] labelstart = {
				"action_",
				"animation_",
				"object_",
				"attach_",
				"uv_",
				"polynormal_",
				"poly_",
				"matlist_",
				"meshlist_",
				"vertex_",
				"vcolor_",
				"normal_",
			};
			for (int u = 0; u < labelstart.Length; u++)
			{
				if (label.Length < labelstart[u].Length + 8) continue;
				if (label.Substring(0, labelstart[u].Length) == labelstart[u])
				{
					string after = label.Substring(labelstart[u].Length, label.Length - labelstart[u].Length);
					if (after.Length == 8 && int.TryParse(after, NumberStyles.AllowHexSpecifier, null, out _) == true) return true;
					if (after.Length == 19)
					{
						if (System.Text.RegularExpressions.Regex.IsMatch(after, @"\A\b[0-9a-fA-F]+\b\Z")) return true;
					}
				}
			}
			return false;
		}
		static void ExportLabels(LandTable land, string path, Dictionary<string, int> labelindex)
		{
			if (labelindex.ContainsKey(land.Name)) return;
			Label_LANDTABLE desc = new Label_LANDTABLE();
			if (!LabelIsAutoGenerated(land.Name)) desc.LandtableName = land.Name;
			if (land.COL != null && land.COL.Count > 0)
			{
				if (!LabelIsAutoGenerated(land.COLName)) desc.COLListName = land.COLName;
				COL[] colarray = land.COL.ToArray();
				desc.ColItemNames = new string[colarray.Length];
				for (int u = 0; u < colarray.Length; u++)
				{
					desc.ColItemNames[u] = colarray[u].Model.Name;
				}
				foreach (COL col in land.COL)
				{
					ExportLabels(col.Model, path, labelindex);
				}
			}
			if (land.Anim != null && land.Anim.Count > 0)
			{
				if (!LabelIsAutoGenerated(land.AnimName)) desc.GeoAnimListName = land.AnimName;
				GeoAnimData[] geoanimarray = land.Anim.ToArray();
				desc.GeoAnimObjectNames = new string[geoanimarray.Length];
				desc.GeoAnimActionNames = new string[geoanimarray.Length];
				for (int u = 0; u < geoanimarray.Length; u++)
				{
					desc.GeoAnimObjectNames[u] = geoanimarray[u].Model.Name;
					desc.GeoAnimActionNames[u] = geoanimarray[u].Animation.Name;
				}
				foreach (GeoAnimData geo in land.Anim)
				{
					ExportLabels(geo.Model, path, labelindex);
					ExportLabels(geo.Animation, path, labelindex);
				}
			}
			IniSerializer.Serialize(desc, Path.Combine(path, labelindex.Count + ".txt"));
			labelindex.Add(land.Name, labelindex.Count);
		}
		static void ExportLabels(NJS_ACTION action, string path, Dictionary<string, int> labelindex)
		{
			if (labelindex.ContainsKey(action.Name)) return;
			Label_ACTION desc = new Label_ACTION();
			if (!LabelIsAutoGenerated(action.Name)) desc.ActionName = action.Name;
			if (!LabelIsAutoGenerated(action.Animation.Name)) desc.MotionName = action.Animation.Name;
			if (!LabelIsAutoGenerated(action.Model.Name)) desc.ObjectName = action.Model.Name;
			IniSerializer.Serialize(desc, Path.Combine(path, labelindex.Count + ".txt"));
			labelindex.Add(action.Name, labelindex.Count);
			if (action.Animation != null && !LabelIsAutoGenerated(action.Animation.Name)) ExportLabels(action.Animation, path, labelindex);
			if (action.Model != null && !LabelIsAutoGenerated(action.Model.Name)) ExportLabels(action.Model, path, labelindex);
		}
		static void ExportLabels(NJS_MOTION mot, string path, Dictionary<string, int> labelindex)
		{
			if (labelindex.ContainsKey(mot.Name)) return;
			Label_MOTION desc = new Label_MOTION();
			if (!LabelIsAutoGenerated(mot.Name)) desc.MotionName = mot.Name;
			if (mot.Models != null)
			{
				if (!LabelIsAutoGenerated(mot.MdataName)) desc.MdataName = mot.MdataName;
				desc.MkeyNames = new Dictionary<int, Label_MKEY>();
				foreach (var item in mot.Models)
				{
					Label_MKEY mkey = new Label_MKEY();
					if (item.Value.Position.Count > 0)
						mkey.PositionName = item.Value.PositionName;
					if (item.Value.Rotation.Count > 0)
						mkey.RotationName = item.Value.RotationName;
					if (item.Value.Scale.Count > 0)
						mkey.ScaleName = item.Value.ScaleName;
					if (item.Value.Vertex.Count > 0)
					{
						mkey.VertexName = item.Value.VertexName;
						mkey.VertexItemNames = new string[item.Value.VertexItemName.Length];
						for (int u = 0; u < item.Value.VertexItemName.Length; u++)
						{
							mkey.VertexItemNames[u] = item.Value.VertexItemName[u];
						}
					}
					if (item.Value.Normal.Count > 0)
					{
						mkey.NormalName = item.Value.NormalName;
						mkey.NormalItemNames = new string[item.Value.NormalItemName.Length];
						for (int u = 0; u < item.Value.NormalItemName.Length; u++)
						{
							mkey.NormalItemNames[u] = item.Value.NormalItemName[u];
						}
					}
					if (item.Value.Vector.Count > 0)
						mkey.VectorName = item.Value.VectorName;
					if (item.Value.Angle.Count > 0)
						mkey.AngleName = item.Value.AngleName;
					if (item.Value.Roll.Count > 0)
						mkey.RollName = item.Value.RollName;
					if (item.Value.Intensity.Count > 0)
						mkey.IntensityName = item.Value.IntensityName;
					if (item.Value.Point.Count > 0)
						mkey.PointName = item.Value.PointName;
					if (item.Value.Target.Count > 0)
						mkey.TargetName = item.Value.TargetName;
					if (item.Value.Color.Count > 0)
						mkey.ColorName = item.Value.ColorName;
					if (item.Value.Spot.Count > 0)
						mkey.SpotName = item.Value.SpotName;
					desc.MkeyNames.Add(item.Key, mkey);
				}
			}
			IniSerializer.Serialize(desc, Path.Combine(path, labelindex.Count + ".txt"));
			labelindex.Add(mot.Name, labelindex.Count);
		}
		static void ExportLabels(NJS_OBJECT mdl, string path, Dictionary<string, int> labelindex)
		{
			if (labelindex.ContainsKey(mdl.Name)) return;
			Label_OBJECT desc = new Label_OBJECT();
			if (!LabelIsAutoGenerated(mdl.Name)) desc.ObjectName = mdl.Name;
			if (mdl.Attach != null)
			{
				if (!LabelIsAutoGenerated(mdl.Attach.Name)) desc.AtachName = mdl.Attach.Name;
				if (mdl.Attach is BasicAttach)
				{
					BasicAttach attach = (BasicAttach)mdl.Attach;
					if (attach.Vertex != null && !LabelIsAutoGenerated(attach.VertexName)) desc.VertexName = attach.VertexName;
					if (attach.Normal != null && !LabelIsAutoGenerated(attach.NormalName)) desc.NormalName = attach.NormalName;
					if (attach.Material != null && !LabelIsAutoGenerated(attach.MaterialName)) desc.MaterialName = attach.MaterialName;
					if (attach.Mesh != null && attach.Mesh.Count > 0)
					{
						if (!LabelIsAutoGenerated(attach.MeshName)) desc.MeshsetOrPolyName = attach.MeshName;
						desc.MeshsetItemNames = new Label_MESHSET[attach.Mesh.Count];
						NJS_MESHSET[] mesharray = attach.Mesh.ToArray();
						for (int u = 0; u < mesharray.Length; u++)
						{
							if (mesharray[u].Poly != null && !LabelIsAutoGenerated(mesharray[u].PolyName)) desc.MeshsetItemNames[u].PolyName = mesharray[u].PolyName;
							if (mesharray[u].UV != null && !LabelIsAutoGenerated(mesharray[u].UVName)) desc.MeshsetItemNames[u].UVName = mesharray[u].UVName;
							if (mesharray[u].PolyNormal != null && !LabelIsAutoGenerated(mesharray[u].PolyNormalName)) desc.MeshsetItemNames[u].PolyNormalName = mesharray[u].PolyNormalName;
							if (mesharray[u].VColor != null && !LabelIsAutoGenerated(mesharray[u].VColorName)) desc.MeshsetItemNames[u].VColorName = mesharray[u].VColorName;
						}
					}
				}
				else if (mdl.Attach is ChunkAttach)
				{
					ChunkAttach attach = (ChunkAttach)mdl.Attach;
					if (attach.Vertex != null && !LabelIsAutoGenerated(attach.VertexName)) desc.VertexName = attach.VertexName;
					if (attach.Poly != null && !LabelIsAutoGenerated(attach.PolyName)) desc.MeshsetOrPolyName = attach.PolyName;
				}
			}
			if (mdl.Children != null && mdl.Children.Count > 0)
			{
				NJS_OBJECT[] childarray = mdl.Children.ToArray();
				desc.ChildNames = new string[mdl.Children.Count];
				for (int u = 0; u < mdl.Children.Count; u++)
				{
					desc.ChildNames[u] = childarray[u].Name;
					ExportLabels(childarray[u], path, labelindex);
				}
			}
			if (mdl.Sibling != null)
			{
				desc.SiblingName = mdl.Sibling.Name;
				ExportLabels(mdl.Sibling, path, labelindex);
			}
			IniSerializer.Serialize(desc, Path.Combine(path, labelindex.Count + ".txt"));
			labelindex.Add(mdl.Name, labelindex.Count);
		}
		static int FindNextItemAddress(Dictionary<int, ItemDescriptor> addresslist, int address)
		{
			int entry = addresslist.Keys.ToList().IndexOf(address);
			return addresslist.Keys.ToList()[entry + 1];
		}
		static void SplitListToINI(Dictionary<int, ItemDescriptor> addresslist, string filename, Game game, uint imageBase, bool bigendian, bool reverse, int address, List<string> deleteditems, Dictionary<string, ItemParams>itemparamslist)
		{
			Console.WriteLine("Creating split INI file: {0}", filename);
			StreamWriter sw = File.CreateText(filename);
			sw.WriteLine("key=" + imageBase.ToString("X8"));
			if (Path.GetExtension(filename).ToLowerInvariant() == ".prs") sw.WriteLine("compressed=true");
			sw.WriteLine("game=" + game.ToString());
			if (bigendian) sw.WriteLine("bigendian=true");
			if (reverse) sw.WriteLine("reverse=true");
			if (address != 0) sw.WriteLine("offset=" + address.ToString("X8"));
			foreach (var entry in addresslist)
			{
				ItemDescriptor v = entry.Value;
				if (deleteditems.Contains(v.ObjectName)) continue;
				//Console.WriteLine("Adding object {0}", v.ObjectName);
				switch (v.ObjectType)
				{
					case "NJS_MOTION":
						if (!itemparamslist.ContainsKey(v.ObjectName)) continue;
						sw.WriteLine("[" + entry.Key.ToString("X8") + "]");
						sw.WriteLine("type=animation");
						sw.WriteLine("address=" + entry.Key.ToString("X8"));
						sw.WriteLine("numparts=" + itemparamslist[v.ObjectName].IntParam.ToString());
						if (itemparamslist[v.ObjectName].BoolParam)
						sw.WriteLine("shortrot=true");
						sw.WriteLine("filename=motions/" + v.ObjectName + ".saanim");
						break;
					case "NJS_ACTION":
						if (!itemparamslist.ContainsKey(v.ObjectName)) continue;
						sw.WriteLine("[" + entry.Key.ToString("X8") + "]");
						sw.WriteLine("type=action");
						sw.WriteLine("address=" + entry.Key.ToString("X8"));
						sw.WriteLine("filename=actions/" + v.ObjectName + ".saanim");
						sw.WriteLine("model=" + itemparamslist[v.ObjectName].StringParam);
						break;
					case "NJS_CNK_OBJECT":
					case "cnkobj":
						sw.WriteLine("[" + entry.Key.ToString("X8") + "]");
						sw.WriteLine("type=chunkmodel");
						sw.WriteLine("address=" + entry.Key.ToString("X8"));
						sw.WriteLine("filename=chunkmodels/" + v.ObjectName + ".sa2mdl");
						break;
					case "NJS_OBJECT":
					case "obj":
						sw.WriteLine("[" + entry.Key.ToString("X8") + "]");
						if (game == Game.SADX) sw.WriteLine("type=basicdxmodel");
						else sw.WriteLine("type=basicmodel");
						sw.WriteLine("address=" + entry.Key.ToString("X8"));
						sw.WriteLine("filename=basicmodels/" + v.ObjectName + ".sa1mdl");
						if (itemparamslist.ContainsKey(v.ObjectName) && itemparamslist[v.ObjectName].StringParam != null && itemparamslist[v.ObjectName].StringParam != "")
						{
							sw.WriteLine("animations=" + itemparamslist[v.ObjectName].StringParam);
						}
						break;
					case "landtable":
					case "LandTable":
					case "_OBJ_LANDTABLE":
						sw.WriteLine("[" + entry.Key.ToString("X8") + "]");
						sw.WriteLine("type=landtable");
						sw.WriteLine("address=" + entry.Key.ToString("X8"));
						sw.WriteLine("filename=levels/" + v.ObjectName + ".sa1lvl");
						break;
				}
			}
			sw.Flush();
			sw.Close();
		}
		static void ParseDictionary(Dictionary<int, ItemDescriptor> addresslist, Dictionary<int, string> labellist, string listpath, bool skip)
		{
			using (var fileStream = File.OpenRead(listpath))
			using (var streamReader = new StreamReader(fileStream, System.Text.Encoding.UTF8, true, 512))
			{
				String line;
				while ((line = streamReader.ReadLine()) != null)
				{
					String[] arr = line.Split(',');
					int value = int.Parse(arr[0], NumberStyles.AllowHexSpecifier);
					if (arr.Length > 2)
					{
						string type = arr[1];
						string name = arr[2];
						if (!addresslist.ContainsKey(value))
						{
							if (!skip)
							{
								addresslist.Add(value, new ItemDescriptor { ObjectType = type, ObjectName = name });
								if (labellist != null) labellist.Add(value, name);
							}
							else addresslist.Add(value, new ItemDescriptor { ObjectType = type, ObjectName = name });
							//Console.WriteLine("Added key {0} value {1}", value.ToString("X"), arr[arr.Length - 1]);
						}
					}
					else if (arr.Length > 1)
					{
						if (!skip && !addresslist.ContainsKey(value))
						{
							string name = arr[1];
							addresslist.Add(value, new ItemDescriptor { ObjectType = "NULL", ObjectName = "NULL" });
							if (labellist != null) labellist.Add(value, name);
							//Console.WriteLine("Added key {0} value {1}", value.ToString("X"), arr[arr.Length - 1]);
						}
					}
				}
			}
		}
		static void Main(string[] args)
		{
			string[] arguments = Environment.GetCommandLineArgs();
			Game game;
			string filename;
			string dir = Environment.CurrentDirectory;
			bool bigendian = false;
			bool reverse = false;
			if (args.Length == 0)
			{
				Console.WriteLine("USplit is a tool that lets you extract any data supported by SA Tools from any binary file.");
				Console.WriteLine("Usage: usplit <GAME> <FILENAME> <KEY> <TYPE> <ADDRESS> <PARAMETER1> <PARAMETER2> [-name <NAME>]\n");
				Console.WriteLine("Argument description:");
				Console.WriteLine("<GAME>: SA1, SADX, SA2, SA2B. Add '_b' (e.g. SADX_b) to switch to Big Endian. Use SADX_X for SADX X360.\n");
				Console.WriteLine("<FILENAME>: The name of the binary file, e.g. sonic.exe.\n");
				Console.WriteLine("<KEY>: Binary key, e.g. 400000 for sonic.exe or C900000 for SA1 STG file.\n");
				Console.WriteLine("<TYPE>: One of the following:\n" +
					"list <offset> <filename> [-skiplabels] [-noanims], binary <length> [hex],\nlandtable, model, basicmodel, basicdxmodel, chunkmodel, gcmodel, action, animation <NJS_OBJECT address> [shortrot],\n" +
					"objlist, startpos, texlist, texnamearray, leveltexlist, triallevellist, bosslevellist, fieldstartpos, soundlist,\nsoundtestlist, nextlevellist, " +
					"levelclearflags, deathzone, levelrankscores, levelranktimes, endpos, levelpathlist,\npathlist,stagelightdatalist, weldlist" +
					"bmitemattrlist, creditstextlist, animindexlist, storysequence, musiclist <count>,\n" +
					"stringarray <count> [language], skyboxscale <count>, stageselectlist <count>, animationlist <count>,\n" +
					"masterstringlist <count>, cutscenetext <count>, recapscreen <count>, npctext <count>\n");
				Console.WriteLine("<ADDRESS>: The location of data in the file.\n");
				Console.WriteLine("<PARAMETER1>: length, count, secondary address etc. depending on data type\n");
				Console.WriteLine("<PARAMETER2>: 'hex' for binary to read length as hexadecimal, 'shortrot' for animation to read rotation as short\n");
				Console.WriteLine("<NAME>: Output file name (optional)\n");
				Console.WriteLine("Press ENTER to exit");
				Console.ReadLine();
				return;
			}
			//Args list: game, filename, key, type, address, [address2/count], [language], [name]
			switch (args[0].ToLowerInvariant())
			{
				case "sa1":
					game = Game.SA1;
					break;
				case "sa1_b":
					game = Game.SA1;
					bigendian = true;
					break;
				case "sadx":
					game = Game.SADX;
					break;
				case "sadx_b":
					game = Game.SADX;
					bigendian = true;
					break;
				case "sadx_x":
					game = Game.SADX;
					bigendian = true;
					reverse = true;
					break;
				case "sa2":
					game = Game.SA2;
					break;
				case "sa2_b":
					game = Game.SA2;
					bigendian = true;
					break;
				case "sa2b":
					game = Game.SA2B;
					break;
				case "sa2b_b":
					game = Game.SA2B;
					bigendian = true;
					break;
				default:
					Console.WriteLine("Error parsing game type.\nCorrect game types are: SA1, SADX, SA2, SA2B.");
					Console.WriteLine("Press ENTER to exit.");
					Console.ReadLine();
					return;
			}
			string model_extension = ".sa1mdl";
			string landtable_extension = ".sa1lvl";
			ByteConverter.BigEndian = SonicRetro.SAModel.ByteConverter.BigEndian = bigendian;
			ByteConverter.Reverse = SonicRetro.SAModel.ByteConverter.Reverse = reverse;
			filename = args[1];
			byte[] datafile = File.ReadAllBytes(filename);
			if (Path.GetExtension(filename).ToLowerInvariant() == ".prs") datafile = FraGag.Compression.Prs.Decompress(datafile);
			Environment.CurrentDirectory = Path.Combine(Environment.CurrentDirectory, Path.GetDirectoryName(filename));
			uint imageBase = uint.Parse(args[2], NumberStyles.AllowHexSpecifier);
			string type = args[3];
			int address = int.Parse(args[4], NumberStyles.AllowHexSpecifier);
			bool SA2 = game == Game.SA2 | game == Game.SA2B;
			ModelFormat modelfmt = ModelFormat.BasicDX;
			LandTableFormat landfmt = LandTableFormat.SADX;
			switch (game)
			{
				case Game.SA1:
					modelfmt = ModelFormat.Basic;
					landfmt = LandTableFormat.SA1;
					model_extension = ".sa1mdl";
					landtable_extension = ".sa1lvl";
					break;
				case Game.SADX:
					modelfmt = ModelFormat.BasicDX;
					landfmt = LandTableFormat.SADX;
					model_extension = ".sa1mdl";
					landtable_extension = ".sa1lvl";
					break;
				case Game.SA2:
					modelfmt = ModelFormat.Chunk;
					landfmt = LandTableFormat.SA2;
					model_extension = ".sa2mdl";
					landtable_extension = ".sa2lvl";
					break;
				case Game.SA2B:
					modelfmt = ModelFormat.Chunk;
					landfmt = LandTableFormat.SA2B;
					model_extension = ".sa2mdl";
					landtable_extension = ".sa2blvl";
					break;
			}
			Dictionary<string, MasterObjectListEntry> masterobjlist = new Dictionary<string, MasterObjectListEntry>();
			Dictionary<string, Dictionary<string, int>> objnamecounts = new Dictionary<string, Dictionary<string, int>>();
			string fileOutputPath = dir + "\\" + address.ToString("X");
			Console.WriteLine("Game: {0}, file: {1}, key: 0x{2}, splitting {3} at 0x{4}", game.ToString(), filename, imageBase.ToString("X"), type, address.ToString("X"));
			if (args[args.Length - 2] == "-name")
			{
				fileOutputPath = dir + "\\" + args[args.Length - 1];
				Console.WriteLine("Name: {0}", args[args.Length - 1]);
			}
			try
			{
				switch (type.ToLowerInvariant())
				{
					case "match":
						Dictionary<int, string> matchresultlist = new Dictionary<int, string>(); //Final list of 2004PC model names
						Dictionary<int, ItemDescriptor> addresslist_m = new Dictionary<int, ItemDescriptor>(); //Main list of addresses, types and labels
						ParseDictionary(addresslist_m, null, args[5], false);
						using (TextReader addr_matchlist = File.OpenText(dir + "\\newmodels.txt"))
						{
							string line = addr_matchlist.ReadLine();
							while (line != null)
							{
								string[] split = line.Split(',');
								int x360addr = int.Parse(split[1], NumberStyles.AllowHexSpecifier);
								int dx2004addr = int.Parse(split[0], NumberStyles.AllowHexSpecifier);
								if (matchresultlist.ContainsKey(dx2004addr))
								{
									Console.WriteLine("Address {0} already contains label {1}", dx2004addr.ToString("X"), matchresultlist[dx2004addr]);
								}
								else if (addresslist_m.ContainsKey(x360addr))
								{
									matchresultlist.Add(dx2004addr, addresslist_m[x360addr].ObjectName);
									Console.WriteLine("{0} is {1}", dx2004addr.ToString("X"), addresslist_m[x360addr].ObjectName);
								}
								line = addr_matchlist.ReadLine();
							}
						}
						IniSerializer.Serialize(matchresultlist, System.IO.Path.Combine(dir, Path.GetFileNameWithoutExtension(args[5]) + "_match.txt"));
						Console.WriteLine("Matching complete. Labels are saved in " + System.IO.Path.Combine(dir, Path.GetFileNameWithoutExtension(args[5]) + "_match.txt"));
						break;
					case "list":
						byte[] data;
						//Start offset
						if (address != 0)
						{
							byte[] datafile_new = new byte[address + datafile.Length];
							datafile.CopyTo(datafile_new, address);
							data = datafile_new;
						}
						else data = datafile;
						bool skiplabels = false;
						bool noanims = false;
						if (args.Length > 6)
						{
							if (args[args.Length - 1] == "-skiplabels" || args[args.Length - 2] == "-skiplabels") skiplabels = true;
							if (args[args.Length - 1] == "-noanims") noanims = true;
						}
						Dictionary<int, ItemDescriptor> addresslist = new Dictionary<int, ItemDescriptor>(); //Main list of addresses, types and labels
						Dictionary<int, string> labellist = new Dictionary<int, string>(); //List of labels for creating objects in SA Tools
						Dictionary<string, int> labelindex = new Dictionary<string, int>(); //List of object names and matching indices in label match list
						Dictionary<string, List<string>> actionlist = new Dictionary<string, List<string>>(); //List of actions to tell which motions to assign/delete later
						List<LandTable> landlist = new List<LandTable>(); //List of landtables to tell which objects/animations to delete later
						List<string> deleteditems = new List<string>(); //List of items not to put in the split INI
						List<NJS_MOTION> motionslist = new List<NJS_MOTION>(); //List of motions for action assignment
						Dictionary<string, ItemParams> itemparamlist = new Dictionary<string, ItemParams>(); //List of object parameters such as node count for motions
						ParseDictionary(addresslist, labellist, args[5], skiplabels);
						Directory.CreateDirectory(dir + "\\chunkmodels");
						Directory.CreateDirectory(dir + "\\basicmodels");
						Directory.CreateDirectory(dir + "\\labels");
						Directory.CreateDirectory(dir + "\\levels");
						Directory.CreateDirectory(dir + "\\actions");
						Directory.CreateDirectory(dir + "\\motions");
						//Scan for motions first
						foreach (var entry in addresslist)
						{
							ItemDescriptor v = entry.Value;
							if (v.ObjectType == "NJS_MOTION")
							{
								if (noanims) continue;
								fileOutputPath = dir + "\\motions\\" + v.ObjectName + ".saanim";
								Console.WriteLine("Splitting {0} {1} at {2}", v.ObjectType, v.ObjectName, entry.Key.ToString("X"));
								try
								{
									int mdataarraypointer = ByteConverter.ToInt32(data, int.Parse(entry.Key.ToString("X"), NumberStyles.AllowHexSpecifier)) - (int)imageBase;
									if (addresslist.ContainsKey(mdataarraypointer))
									{
										ItemDescriptor v2 = new ItemDescriptor();
										addresslist.TryGetValue(mdataarraypointer, out v2);
										int nextitem = FindNextItemAddress(addresslist, mdataarraypointer);
										int size = nextitem - (mdataarraypointer);
										int divide = 16;
										if (v2.ObjectType == "NJS_MDATA2") divide = 16;
										else if (v2.ObjectType == "NJS_MDATA3") divide = 24;
										else if (v2.ObjectType == "NJS_MDATA4") divide = 32;
										if (size % divide != 0)
										{
											Console.WriteLine("Error calculating array size for {0} at {1}, size {2} divided by {3}, assuming {4}", v2.ObjectType, (mdataarraypointer).ToString("X"), size, divide, size / divide);
										}
										int count = size / divide;
										//Console.WriteLine("{0} at {1}, next item: {2}, size {3}, count {4}", v2.ObjectType, mdataarraypointer.ToString("X"), nextitem.ToString("X"), size.ToString(), count.ToString());
										NJS_MOTION motion;
										if (v2.ObjectName.Substring(0, 8) == "mdata_al")
										{
											//Console.WriteLine("ROT");
											motion = new NJS_MOTION(data, entry.Key, imageBase, count, labellist, true);
										}
										else
										{
											motion = new NJS_MOTION(data, entry.Key, imageBase, count, labellist, false);
										}
										motion.Save(fileOutputPath);
										motionslist.Add(motion);
										ExportLabels(motion, dir + "\\labels", labelindex);
										itemparamlist.Add(motion.Name, new ItemParams { BoolParam = motion.ShortRot, IntParam = motion.ModelParts });
										//Console.WriteLine("Added motion {0}", motion.Name);
									}
								}
								catch (Exception ex)
								{
									Console.WriteLine("Split failed: {0}", ex.ToString());
								}
							}
						}
						//Scan for actions
						foreach (KeyValuePair<int, ItemDescriptor> entry in addresslist)
						{
							ItemDescriptor v = entry.Value;
							if (v.ObjectType == "NJS_ACTION")
							{
								if (noanims) continue;
								fileOutputPath = dir + "\\actions\\" + v.ObjectName;
								Console.WriteLine("Splitting {0} {1} at {2}", v.ObjectType, v.ObjectName, entry.Key.ToString("X"));
								try
								{
									NJS_ACTION ani = new NJS_ACTION(data, int.Parse(entry.Key.ToString("X"), NumberStyles.AllowHexSpecifier), imageBase, modelfmt, labellist, new Dictionary<int, Attach>());
									foreach (NJS_MOTION item in motionslist)
									{
										if (ani.Animation.Name == item.Name)
										{
											string aniName = ani.Name;
											ani = new NJS_ACTION(ani.Model, item);
											ani.Name = aniName;
											Console.WriteLine("Reusing motion {0} for action {1}", item.Name, ani.Name);
											deleteditems.Add(ani.Animation.Name);
											File.Delete(dir + "\\motions\\" + ani.Animation.Name + ".saanim");
										}
									}
									if (ani.Animation.ModelParts == 0)
									{
										Console.WriteLine("Animation of action {0} has no model parts, skipping", ani.Name);
										continue;
									}
									else
									{
										if (!actionlist.ContainsKey(ani.Model.Name))
										{
											List<string> actions = new List<string>();
											if (!skiplabels) actions.Add(ani.Name);
											else actions.Add(ani.Name.Substring(7, ani.Name.Length - 7));
											actionlist.Add(ani.Model.Name, actions);
											Console.WriteLine("New animation list for model {0} starting with {1}", ani.Model.Name, ani.Name);
										}
										else
										{
											foreach (KeyValuePair<string, List<string>> item in actionlist)
											{
												if (item.Key == ani.Model.Name)
												{
													if (!item.Value.Contains(ani.Animation.Name))
													{
														if (!skiplabels) item.Value.Add(ani.Name);
														else item.Value.Add(ani.Name.Substring(10, ani.Name.Length - 10));
														Console.WriteLine("Added animation for model {0}:{1}", ani.Model.Name, ani.Name);
													}
												}
											}
										}
										ani.Animation.Save(fileOutputPath + ".saanim");
										ExportLabels(ani, dir + "\\labels", labelindex);
										itemparamlist.Add(ani.Name, new ItemParams { StringParam = ani.Model.Name });
									}
								}
								catch (Exception ex)
								{
									Console.WriteLine("Split failed: {0}", ex.ToString());
								}
							}
						}
						//Scan for models and levels
						foreach (var entry in addresslist)
						{
							ItemDescriptor v = entry.Value;
							switch (v.ObjectType)
							{
								case "NJS_CNK_OBJECT":
								case "cnkobj":
									model_extension = ".sa2mdl";
									fileOutputPath = dir + "\\chunkmodels\\" + v.ObjectName;
									Console.WriteLine("Splitting {0} {1} at {2}", v.ObjectType, v.ObjectName, entry.Key.ToString("X"));
									try
									{
										NJS_OBJECT mdl = new NJS_OBJECT(data, int.Parse(entry.Key.ToString("X"), NumberStyles.AllowHexSpecifier), imageBase, ModelFormat.Chunk, labellist, new Dictionary<int, Attach>());
										List<string> mdlanis = new List<string>();
										if (actionlist.ContainsKey(mdl.Name))
										{
											foreach (KeyValuePair<string, List<string>> item in actionlist)
											{
												if (item.Key == mdl.Name)
												{
													foreach (string animname in item.Value)
													{
														mdlanis.Add("../actions/" + animname + ".saanim");
														Console.WriteLine("Adding animation {0} for model {1}", animname, mdl.Name);
													}
												}
											}
										}
										ModelFile.CreateFile(fileOutputPath + model_extension, mdl, mdlanis.ToArray(), null, null, null, ModelFormat.Chunk);
										ExportLabels(mdl, dir + "\\labels", labelindex);
										if (mdl.Children.Count > 0)
										{
											foreach (NJS_OBJECT child in mdl.Children)
											{
												if (!skiplabels)
												{
													File.Delete(dir + "\\chunkmodels\\" + child.Name + model_extension);
													deleteditems.Add(child.Name);
												}
												else
												{
													if (File.Exists((dir + "\\chunkmodels\\" + child.Name.Substring(7, child.Name.Length - 7) + model_extension)))
													{
														File.Delete(dir + "\\chunkmodels\\" + child.Name.Substring(7, child.Name.Length - 7) + model_extension);
														deleteditems.Add(child.Name.Substring(7, child.Name.Length - 7));
													}
													else
													{
														int childaddr = int.Parse(child.Name.Substring(7, child.Name.Length - 7), NumberStyles.AllowHexSpecifier);
														//Console.WriteLine("Deleting at address :{0}", childaddr.ToString("X8"));
														foreach (var item in addresslist)
														{
															if (item.Key == childaddr)
															{
																ItemDescriptor v2 = item.Value;
																//Console.WriteLine("Deleting file: {0}", dir + "\\chunkmodels\\" + v2.ObjectName + model_extension);
																File.Delete(dir + "\\chunkmodels\\" + v2.ObjectName + model_extension);
																deleteditems.Add(v2.ObjectName);
															}
														}
													}
												}
											}
										}
										if (mdl.Sibling != null)
										{
											if (!skiplabels)
											{
												File.Delete(dir + "\\chunkmodels\\" + mdl.Sibling.Name + model_extension);
												deleteditems.Add(mdl.Sibling.Name);
											}
											else
											{
												if (File.Exists(dir + "\\chunkmodels\\" + mdl.Sibling.Name.Substring(7, mdl.Sibling.Name.Length - 7) + model_extension))
												{
													File.Delete(dir + "\\chunkmodels\\" + mdl.Sibling.Name.Substring(7, mdl.Sibling.Name.Length - 7) + model_extension);
													deleteditems.Add(mdl.Sibling.Name.Substring(7, mdl.Sibling.Name.Length - 7));
												}
												else
												{
													foreach (var item in addresslist)
													{
														if (item.Key == int.Parse(mdl.Sibling.Name.Substring(7, mdl.Sibling.Name.Length - 7), NumberStyles.AllowHexSpecifier))
														{
															ItemDescriptor v2 = item.Value;
															//Console.WriteLine("Deleting file: {0}", dir + "\\chunkmodels\\" + v2.ObjectName + model_extension);
															File.Delete(dir + "\\chunkmodels\\" + v2.ObjectName + model_extension);
															deleteditems.Add(v2.ObjectName);
														}
													}
												}
											}
										}
										if (mdlanis.Count > 0)
										{
											string allmodels = string.Join(",", mdlanis);
											itemparamlist.Add(mdl.Name, new ItemParams { StringParam = allmodels });
										}
									}
									catch (Exception ex)
									{
										Console.WriteLine("Split failed: {0}", ex.ToString());
									}
									break;
								case "NJS_OBJECT":
								case "obj":
									model_extension = ".sa1mdl";
									fileOutputPath = dir + "\\basicmodels\\" + v.ObjectName;
									Console.WriteLine("Splitting {0} {1} at {2}", v.ObjectType, v.ObjectName, entry.Key.ToString("X"));
									try
									{
										NJS_OBJECT mdl = new NJS_OBJECT(data, int.Parse(entry.Key.ToString("X"), NumberStyles.AllowHexSpecifier), imageBase, modelfmt, labellist, new Dictionary<int, Attach>());
										List<string> mdlanis = new List<string>();
										if (actionlist.ContainsKey(mdl.Name))
										{
											foreach (KeyValuePair<string, List<string>> item in actionlist)
											{
												if (item.Key == mdl.Name)
												{
													foreach (string animname in item.Value)
													{
														mdlanis.Add("../actions/" + animname + ".saanim");
														Console.WriteLine("Adding animation {0} for model {1}", animname, mdl.Name);
													}
												}
											}
										}
										ModelFile.CreateFile(fileOutputPath + model_extension, mdl, mdlanis.ToArray(), null, null, null, modelfmt);
										ExportLabels(mdl, dir + "\\labels", labelindex);
										if (mdl.Children.Count > 0)
										{
											foreach (NJS_OBJECT child in mdl.Children)
											{
												if (!skiplabels)
												{
													File.Delete(dir + "\\basicmodels\\" + child.Name + model_extension);
													deleteditems.Add(child.Name);
												}
												else
												{
													if (File.Exists((dir + "\\basicmodels\\" + child.Name.Substring(7, child.Name.Length - 7) + model_extension)))
													{
														File.Delete(dir + "\\basicmodels\\" + child.Name.Substring(7, child.Name.Length - 7) + model_extension);
														deleteditems.Add(child.Name.Substring(7, child.Name.Length - 7));
													}
													else
													{
														int childaddr = int.Parse(child.Name.Substring(7, child.Name.Length - 7), NumberStyles.AllowHexSpecifier);
														//Console.WriteLine("Deleting at address :{0}", childaddr.ToString("X8"));
														foreach (var item in addresslist)
														{
															if (item.Key == childaddr)
															{
																ItemDescriptor v2 = item.Value;
																//Console.WriteLine("Deleting file: {0}", dir + "\\basicmodels\\" + v2.ObjectName + model_extension);
																File.Delete(dir + "\\basicmodels\\" + v2.ObjectName + model_extension);
																deleteditems.Add(v2.ObjectName);
															}
														}
													}
												}
											}
										}
										if (mdl.Sibling != null)
										{
											if (!skiplabels)
											{
												File.Delete(dir + "\\basicmodels\\" + mdl.Sibling.Name + model_extension);
												deleteditems.Add(mdl.Sibling.Name);
											}
											else
											{
												if (File.Exists(dir + "\\basicmodels\\" + mdl.Sibling.Name.Substring(7, mdl.Sibling.Name.Length - 7) + model_extension))
												{
													File.Delete(dir + "\\basicmodels\\" + mdl.Sibling.Name.Substring(7, mdl.Sibling.Name.Length - 7) + model_extension);
													deleteditems.Add(mdl.Sibling.Name.Substring(7, mdl.Sibling.Name.Length - 7));
												}
												else
												{
													foreach (var item in addresslist)
													{
														if (item.Key == int.Parse(mdl.Sibling.Name.Substring(7, mdl.Sibling.Name.Length - 7), NumberStyles.AllowHexSpecifier))
														{
															ItemDescriptor v2 = item.Value;
															//Console.WriteLine("Deleting file: {0}", dir + "\\basicmodels\\" + v2.ObjectName + model_extension);
															File.Delete(dir + "\\basicmodels\\" + v2.ObjectName + model_extension);
															deleteditems.Add(v2.ObjectName);
														}
													}
												}
											}
										}
										if (mdlanis.Count > 0)
										{
											string allmodels = string.Join(",", mdlanis);
											itemparamlist.Add(mdl.Name, new ItemParams { StringParam = allmodels });
										}
									}
									catch (Exception ex)
									{
										Console.WriteLine("Split failed: {0}", ex.ToString());
									}
									break;
								case "LandTable":
								case "_OBJ_LANDTABLE":
									fileOutputPath = dir + "\\levels\\" + v.ObjectName;
									Console.WriteLine("Splitting {0} {1} at {2}", v.ObjectType, v.ObjectName, entry.Key.ToString("X"));
									try
									{
										LandTable land = new LandTable(data, int.Parse(entry.Key.ToString("X"), NumberStyles.AllowHexSpecifier), imageBase, landfmt, labellist);
										land.SaveToFile(fileOutputPath + landtable_extension, landfmt);
										ExportLabels(land, dir + "\\labels", labelindex);
										landlist.Add(land);
									}
									catch (Exception ex)
									{
										Console.WriteLine("Split failed: {0}", ex.ToString());
									}
									break;
							}
						}
						//Clean up stuff that is included in landtables
						foreach (LandTable land in landlist)
						{
							if (land.COL.Count > 0)
							{
								foreach (COL col in land.COL)
								{
									if (!skiplabels)
									{
										File.Delete(dir + "\\basicmodels\\" + col.Model.Name + model_extension);
										deleteditems.Add(col.Model.Name);
									}
									else
									{
										//Console.WriteLine("Deleting file {0}", dir + "\\" + col.Model.Name + model_extension);
										File.Delete(dir + "\\basicmodels\\" + col.Model.Name.Substring(7, col.Model.Name.Length - 7) + model_extension);
										deleteditems.Add(col.Model.Name.Substring(7, col.Model.Name.Length - 7));
									}
								}
							}
							if (land.Anim.Count > 0)
							{
								foreach (GeoAnimData anim in land.Anim)
								{
									if (!skiplabels)
									{
										File.Delete(dir + "\\basicmodels\\" + anim.Model.Name + model_extension);
										File.Delete(dir + "\\motions\\" + anim.Animation.Name + ".saanim");
										deleteditems.Add(anim.Model.Name);
										deleteditems.Add(anim.Animation.Name);
									}
									else
									{
										File.Delete(dir + "\\basicmodels\\" + anim.Model.Name.Substring(7, anim.Model.Name.Length - 7) + model_extension);
										File.Delete(dir + "\\motions\\" + anim.Animation.Name.Substring(10, anim.Animation.Name.Length - 10) + ".saanim");
										deleteditems.Add(anim.Model.Name.Substring(7, anim.Model.Name.Length - 7));
										deleteditems.Add(anim.Animation.Name.Substring(10, anim.Animation.Name.Length - 10));
									}
									//Console.WriteLine("Deleting file {0}", dir + "\\" + anim.Model.Name + model_extension);
								}
							}
						}
						//Export labels
						Console.WriteLine("Creating labels: {0}", System.IO.Path.Combine(dir, Path.GetFileNameWithoutExtension(filename) + "_labels.txt"));
						IniSerializer.Serialize(labellist, System.IO.Path.Combine(dir, Path.GetFileNameWithoutExtension(filename) + "_labels.txt"));
						/*
						//List deleted items
						Console.WriteLine("Deleted items: {0}", System.IO.Path.Combine(dir, Path.GetFileNameWithoutExtension(filename) + "_deleted.txt"));
						IniSerializer.Serialize(deleteditems, System.IO.Path.Combine(dir, Path.GetFileNameWithoutExtension(filename) + "_deleted.txt"));
						//Serialize the descriptors
						Console.WriteLine("Debug output items: {0}", System.IO.Path.Combine(dir, Path.GetFileNameWithoutExtension(filename) + "_debug.txt"));
						IniSerializer.Serialize(addresslist, System.IO.Path.Combine(dir, Path.GetFileNameWithoutExtension(filename) + "_debug.txt"));
						*/
						//Create split INI
						IniSerializer.Serialize(labelindex, System.IO.Path.Combine(dir, "labels", "index.txt"));
						SplitListToINI(addresslist, dir + "\\" + Path.GetFileNameWithoutExtension(filename) + ".ini", game, imageBase, bigendian, reverse, address, deleteditems, itemparamlist);
						break;
					case "landtable":
						new LandTable(datafile, address, imageBase, landfmt).SaveToFile(fileOutputPath + landtable_extension, landfmt);
						break;
					case "model":
						{
							NJS_OBJECT mdl = new NJS_OBJECT(datafile, address, imageBase, modelfmt, new Dictionary<int, Attach>());
							ModelFile.CreateFile(fileOutputPath + model_extension, mdl, null, null, null, null, modelfmt);
						}
						break;
					case "basicmodel":
						{
							NJS_OBJECT mdl = new NJS_OBJECT(datafile, address, imageBase, ModelFormat.Basic, new Dictionary<int, Attach>());
							ModelFile.CreateFile(fileOutputPath + ".sa1mdl", mdl, null, null, null, null, ModelFormat.Basic);
						}
						break;
					case "basicdxmodel":
						{
							NJS_OBJECT mdl = new NJS_OBJECT(datafile, address, imageBase, ModelFormat.BasicDX, new Dictionary<int, Attach>());
							ModelFile.CreateFile(fileOutputPath + ".sa1mdl", mdl, null, null, null, null, ModelFormat.BasicDX);
						}
						break;
					case "chunkmodel":
						{
							NJS_OBJECT mdl = new NJS_OBJECT(datafile, address, imageBase, ModelFormat.Chunk, new Dictionary<int, Attach>());
							ModelFile.CreateFile(fileOutputPath + ".sa2mdl", mdl, null, null, null, null, ModelFormat.Chunk);
						}
						break;
					case "gcmodel":
						{
							NJS_OBJECT mdl = new NJS_OBJECT(datafile, address, imageBase, ModelFormat.GC, new Dictionary<int, Attach>());
							ModelFile.CreateFile(fileOutputPath + ".sa2mdl", mdl, null, null, null, null, ModelFormat.GC);
						}
						break;
					case "action":
						{
							NJS_ACTION ani = new NJS_ACTION(datafile, address, imageBase, modelfmt, new Dictionary<int, Attach>());
							ani.Animation.Save(fileOutputPath + ".saanim");
							string[] mdlanis = new string[0];
							NJS_OBJECT mdl = ani.Model;
							mdlanis = (fileOutputPath + ".saanim").Split(',');
							ModelFile.CreateFile(fileOutputPath + "_model" + model_extension, mdl, mdlanis, null, null, null, modelfmt);
						}
						break;
					case "animation":
						{
							bool shortrot_enabled = false;
							if (args.Length > 6 && args[6] == "shortrot") shortrot_enabled = true;
							NJS_OBJECT mdl = new NJS_OBJECT(datafile, int.Parse(args[5], NumberStyles.AllowHexSpecifier), imageBase, modelfmt, new Dictionary<int, Attach>());
							new NJS_MOTION(datafile, address, imageBase, mdl.CountAnimated(), shortrot: shortrot_enabled).Save(fileOutputPath + ".saanim");
							string[] mdlanis = new string[0];
							mdlanis = (fileOutputPath + ".saanim").Split(',');
							ModelFile.CreateFile(fileOutputPath + "_model" + model_extension, mdl, mdlanis, null, null, null, modelfmt);
						}
						break;
					case "objlist":
						{
							ObjectListEntry[] objs = ObjectList.Load(datafile, address, imageBase, SA2);
							foreach (ObjectListEntry obj in objs)
							{
								if (!masterobjlist.ContainsKey(obj.CodeString))
									masterobjlist.Add(obj.CodeString, new MasterObjectListEntry(obj));
								if (!objnamecounts.ContainsKey(obj.CodeString))
									objnamecounts.Add(obj.CodeString, new Dictionary<string, int>() { { obj.Name, 1 } });
								else if (!objnamecounts[obj.CodeString].ContainsKey(obj.Name))
									objnamecounts[obj.CodeString].Add(obj.Name, 1);
								else
									objnamecounts[obj.CodeString][obj.Name]++;
							}
							objs.Save(fileOutputPath + ".ini");
						}
						break;
					case "startpos":
						if (SA2)
							SA2StartPosList.Load(datafile, address).Save(fileOutputPath + ".ini");
						else
							SA1StartPosList.Load(datafile, address).Save(fileOutputPath + ".ini");
						break;
					case "texlist":
						TextureList.Load(datafile, address, imageBase).Save(fileOutputPath + ".ini");
						break;
					case "texnamearray":
						TexnameArray texnames = new TexnameArray(datafile, address, imageBase);
						StreamWriter sw = File.CreateText(fileOutputPath + "_texnames.txt");
						for (int u = 0; u < texnames.NumTextures; u++)
						{
							sw.WriteLine(texnames.TextureNames[u] + ".pvr");
						}
						sw.Flush();
						sw.Close();
						break;
					case "leveltexlist":
						new LevelTextureList(datafile, address, imageBase).Save(fileOutputPath + ".ini");
						break;
					case "triallevellist":
						TrialLevelList.Save(TrialLevelList.Load(datafile, address, imageBase), fileOutputPath + ".ini");
						break;
					case "bosslevellist":
						BossLevelList.Save(BossLevelList.Load(datafile, address), fileOutputPath + ".ini");
						break;
					case "fieldstartpos":
						FieldStartPosList.Load(datafile, address).Save(fileOutputPath + ".ini");
						break;
					case "soundtestlist":
						SoundTestList.Load(datafile, address, imageBase).Save(fileOutputPath + ".ini");
						break;
					case "musiclist":
						{
							int muscnt = int.Parse(args[5], NumberStyles.Integer, NumberFormatInfo.InvariantInfo);
							MusicList.Load(datafile, address, imageBase, muscnt).Save(fileOutputPath + ".ini");
						}
						break;
					case "soundlist":
						SoundList.Load(datafile, address, imageBase).Save(fileOutputPath + ".ini");
						break;
					case "stringarray":
						{
							int cnt = int.Parse(args[5], NumberStyles.Integer, NumberFormatInfo.InvariantInfo);
							Languages lang = Languages.Japanese;
							if (args.Length > 6)
								lang = (Languages)Enum.Parse(typeof(Languages), args[6], true);
							StringArray.Load(datafile, address, imageBase, cnt, lang).Save(fileOutputPath + ".txt");
						}
						break;
					case "nextlevellist":
						NextLevelList.Load(datafile, address).Save(fileOutputPath + ".ini");
						break;
					case "cutscenetext":
						{
							int cnt = int.Parse(args[5], NumberStyles.Integer, NumberFormatInfo.InvariantInfo);
							new CutsceneText(datafile, address, imageBase, cnt).Save(fileOutputPath + ".txt", out string[] hashes);
						}
						break;
					case "recapscreen":
						{
							int cnt = int.Parse(args[5], NumberStyles.Integer, NumberFormatInfo.InvariantInfo);
							RecapScreenList.Load(datafile, address, imageBase, cnt).Save(fileOutputPath + ".txt", out string[][] hashes);
						}
						break;
					case "npctext":
						{
							int cnt = int.Parse(args[5], NumberStyles.Integer, NumberFormatInfo.InvariantInfo);
							NPCTextList.Load(datafile, address, imageBase, cnt).Save(fileOutputPath + ".txt", out string[][] hashes);
						}
						break;
					case "levelclearflags":
						LevelClearFlagList.Save(LevelClearFlagList.Load(datafile, address), fileOutputPath + ".ini");
						break;
					case "deathzone":
						{
							List<DeathZoneFlags> flags = new List<DeathZoneFlags>();
							string path = Path.GetDirectoryName(fileOutputPath);
							List<string> hashes = new List<string>();
							int num = 0;
							while (ByteConverter.ToUInt32(datafile, address + 4) != 0)
							{
								flags.Add(new DeathZoneFlags(datafile, address));
								string file = Path.Combine(path, num++.ToString(NumberFormatInfo.InvariantInfo) + (modelfmt == ModelFormat.Chunk ? ".sa2mdl" : ".sa1mdl"));
								ModelFile.CreateFile(file, new NJS_OBJECT(datafile, datafile.GetPointer(address + 4, imageBase), imageBase, modelfmt, new Dictionary<int, Attach>()), null, null, null, null, modelfmt);
								address += 8;
							}
							flags.ToArray().Save(fileOutputPath + ".ini");
						}
						break;
					case "skyboxscale":
						{
							int cnt = int.Parse(args[5], NumberStyles.Integer, NumberFormatInfo.InvariantInfo);
							SkyboxScaleList.Load(datafile, address, imageBase, cnt).Save(fileOutputPath + ".ini");
						}
						break;
					case "stageselectlist":
						{
							int cnt = int.Parse(args[5], NumberStyles.Integer, NumberFormatInfo.InvariantInfo);
							StageSelectLevelList.Load(datafile, address, cnt).Save(fileOutputPath + ".ini");
						}
						break;
					case "levelrankscores":
						LevelRankScoresList.Load(datafile, address).Save(fileOutputPath + ".ini");
						break;
					case "levelranktimes":
						LevelRankTimesList.Load(datafile, address).Save(fileOutputPath + ".ini");
						break;
					case "endpos":
						SA2EndPosList.Load(datafile, address).Save(fileOutputPath + ".ini");
						break;
					case "animationlist":
						{
							int cnt = int.Parse(args[5], NumberStyles.Integer, NumberFormatInfo.InvariantInfo);
							SA2AnimationInfoList.Load(datafile, address, cnt).Save(fileOutputPath + ".ini");
						}
						break;
					case "levelpathlist":
						{
							ushort lvlnum = (ushort)ByteConverter.ToUInt32(datafile, address);
							while (lvlnum != 0xFFFF)
							{
								int ptr = ByteConverter.ToInt32(datafile, address + 4);
								if (ptr != 0)
								{
									ptr = (int)((uint)ptr - imageBase);
									SA1LevelAct level = new SA1LevelAct(lvlnum);
									string lvldir = Path.Combine(fileOutputPath, level.ToString());
									PathList.Load(datafile, ptr, imageBase).Save(lvldir, out string[] lvlhashes);
								}
								address += 8;
								lvlnum = (ushort)ByteConverter.ToUInt32(datafile, address);
							}
						}
						break;
					case "pathlist":
						{
							PathList.Load(datafile, address, imageBase).Save(fileOutputPath, out string[] hashes);
						}
						break;
					case "stagelightdatalist":
						SA1StageLightDataList.Load(datafile, address).Save(fileOutputPath);
						break;
					case "weldlist":
						WeldList.Load(datafile, address, imageBase).Save(fileOutputPath);
						break;
					case "bmitemattrlist":
						BlackMarketItemAttributesList.Load(datafile, address, imageBase).Save(fileOutputPath);
						break;
					case "creditstextlist":
						CreditsTextList.Load(datafile, address, imageBase).Save(fileOutputPath);
						break;
					case "animindexlist":
						{
							Directory.CreateDirectory(fileOutputPath);
							List<string> hashes = new List<string>();
							int i = ByteConverter.ToInt16(datafile, address);
							while (i != -1)
							{
								new NJS_MOTION(datafile, datafile.GetPointer(address + 4, imageBase), imageBase, ByteConverter.ToInt16(datafile, address + 2))
									.Save(fileOutputPath + "/" + i.ToString(NumberFormatInfo.InvariantInfo) + ".saanim");
								hashes.Add(i.ToString(NumberFormatInfo.InvariantInfo) + ":" + HelperFunctions.FileHash(fileOutputPath + "/" + i.ToString(NumberFormatInfo.InvariantInfo) + ".saanim"));
								address += 8;
								i = ByteConverter.ToInt16(datafile, address);
							}
						}
						break;
					case "storysequence":
						SA2StoryList.Load(datafile, address).Save(fileOutputPath);
						break;
					case "masterstringlist":
						{
							int cnt = int.Parse(args[5], NumberStyles.Integer, NumberFormatInfo.InvariantInfo);
							for (int l = 0; l < 5; l++)
							{
								Languages lng = (Languages)l;
								System.Text.Encoding enc = HelperFunctions.GetEncoding(game, lng);
								string ld = Path.Combine(fileOutputPath, lng.ToString());
								Directory.CreateDirectory(ld);
								int ptr = datafile.GetPointer(address, imageBase);
								for (int i = 0; i < cnt; i++)
								{
									int ptr2 = datafile.GetPointer(ptr, imageBase);
									if (ptr2 != 0)
									{
										string fn = Path.Combine(ld, $"{i}.txt");
										File.WriteAllText(fn, datafile.GetCString(ptr2, enc).Replace("\n", "\r\n"));
									}
									ptr += 4;
								}
								address += 4;
							}
						}
						break;
					case "binary":
						{
							int length;
							if (args.Length > 6 && args[6] == "hex") length = int.Parse(args[5], NumberStyles.AllowHexSpecifier);
							else length = int.Parse(args[5]);
							byte[] bin = new byte[length];
							Array.Copy(datafile, address, bin, 0, bin.Length);
							File.WriteAllBytes(fileOutputPath + ".bin", bin);
							Console.WriteLine("Length: {0} (0x{1}) bytes", length.ToString(), length.ToString("X"));
						}
						break;
					default:
						{
							Console.WriteLine("Error parsing data type. Run the program without arguments for a list of usable data types.");
							Console.WriteLine("Press ENTER to exit.");
							Console.ReadLine();
							return;
						}
				}
			}
			catch (Exception ex)
			{
				Console.WriteLine("Split operation failed: " + ex.ToString());
			}
		}
	}
}